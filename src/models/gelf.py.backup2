"""GELF message models for Graylog integration."""

import json
import time
from typing import Any, Dict, Optional, Union
from datetime import datetime
from pydantic import BaseModel, Field, field_validator


def flatten_dict(data: Dict[str, Any], parent_key: str = '', separator: str = '_') -> Dict[str, Any]:
    """
    Recursively flatten a nested dictionary.
    
    Args:
        data: Dictionary to flatten
        parent_key: Current parent key path
        separator: Separator to use between keys
    
    Returns:
        Flattened dictionary with concatenated keys
    """
    items = []
    
    for key, value in data.items():
        # Create new key with parent path
        new_key = f"{parent_key}{separator}{key}" if parent_key else key
        
        if isinstance(value, dict):
            # Recursively flatten nested dictionaries
            items.extend(flatten_dict(value, new_key, separator).items())
        elif isinstance(value, list):
            # Handle lists by creating indexed fields or converting to JSON
            if len(value) > 0 and all(isinstance(item, dict) for item in value):
                # If list contains dictionaries, flatten each with index
                for i, item in enumerate(value):
                    if isinstance(item, dict):
                        indexed_key = f"{new_key}_{i}"
                        items.extend(flatten_dict(item, indexed_key, separator).items())
                    else:
                        items.append((f"{new_key}_{i}", str(item)))
            else:
                # For simple lists or mixed types, convert to JSON string
                items.append((new_key, json.dumps(value)))
        elif isinstance(value, datetime):
            # Convert datetime to ISO string
            items.append((new_key, value.isoformat()))
        elif value is None:
            # Skip None values
            continue
        else:
            # Keep primitive values as-is, but convert to string for safety
            items.append((new_key, str(value)))
    
    return dict(items)


class GELFMessage(BaseModel):
    """
    GELF (Graylog Extended Log Format) message structure.
    
    Based on GELF specification: https://docs.graylog.org/docs/gelf
    """
    
    # Required GELF fields
    version: str = Field(default="1.1", description="GELF spec version")
    host: str = Field(..., description="Source host")
    short_message: str = Field(..., description="Short descriptive message")
    
    # Optional GELF fields
    full_message: Optional[str] = Field(None, description="Long message")
    timestamp: Optional[float] = Field(None, description="Unix timestamp")
    level: Optional[int] = Field(6, description="Syslog level (default: INFO)")
    facility: Optional[str] = Field("nb_streamer", description="Log facility")
    
    # Custom fields (must be prefixed with _)
    custom_fields: Dict[str, Any] = Field(default_factory=dict, description="Custom GELF fields")
    
    @field_validator("timestamp", mode="before")
    @classmethod
    def set_timestamp(cls, v):
        """Set timestamp to current time if not provided."""
        if v is None:
            return time.time()
        if isinstance(v, datetime):
            return v.timestamp()
        return v
    
    @field_validator("custom_fields")
    @classmethod
    def validate_custom_fields(cls, v):
        """Ensure all custom fields are prefixed with underscore."""
        validated = {}
        for key, value in v.items():
            if not key.startswith("_"):
                key = f"_{key}"
            validated[key] = value
        return validated
    
    def model_dump_dict(self, **kwargs) -> Dict[str, Any]:
        """Convert to dictionary with custom fields flattened."""
        data = self.model_dump(exclude={"custom_fields"}, **kwargs)
        
        # Add custom fields at top level
        if self.custom_fields:
            data.update(self.custom_fields)
            
        # Remove None values
        return {k: v for k, v in data.items() if v is not None}
    
    def dict(self, **kwargs) -> Dict[str, Any]:
        """Backward compatibility method."""
        return self.model_dump_dict(**kwargs)
    
    def to_json(self) -> str:
        """Convert to JSON string for transmission."""
        return json.dumps(self.dict(), separators=(",", ":"))
    
    @classmethod
    def from_netbird_event(
        cls,
        event_data: Dict[str, Any],
        host: str,
        tenant_id: str,
        short_message: Optional[str] = None
    ) -> "GELFMessage":
        """
        Create GELF message from Netbird event data with flattened fields.
        
        Args:
            event_data: Netbird event data dictionary
            host: Source host identifier
            tenant_id: Tenant/client identifier
            short_message: Override for short message
        """
        # Generate short message if not provided
        if not short_message:
            event_type = event_data.get("type", event_data.get("event_type", "unknown"))
            action = event_data.get("action", "")
            user = event_data.get("user", "")
            if action and user:
                short_message = f"Netbird {event_type}: {action} by {user}"
            elif event_type:
                short_message = f"Netbird {event_type}"
            else:
                short_message = "Netbird event"
        
        # Handle timestamp
        timestamp = None
        if "timestamp" in event_data:
            ts_value = event_data["timestamp"]
            if isinstance(ts_value, str):
                try:
                    # Try parsing ISO format
                    dt = datetime.fromisoformat(ts_value.replace("Z", "+00:00"))
                    timestamp = dt.timestamp()
                except ValueError:
                    # If parsing fails, use current time
                    timestamp = time.time()
            elif isinstance(ts_value, (int, float)):
                timestamp = ts_value
            elif isinstance(ts_value, datetime):
                timestamp = ts_value.timestamp()
        
        # Convert level to syslog level if it's a string
        level = 6  # Default INFO
        if "level" in event_data:
            level_str = str(event_data["level"]).upper()
            level_mapping = {
                "EMERGENCY": 0, "EMERG": 0,
                "ALERT": 1,
                "CRITICAL": 2, "CRIT": 2,
                "ERROR": 3, "ERR": 3,
                "WARNING": 4, "WARN": 4,
                "NOTICE": 5,
                "INFO": 6, "INFORMATION": 6,
                "DEBUG": 7
            }
            level = level_mapping.get(level_str, 6)
        
        # Prepare custom fields with flattened structure
        custom_fields = {}
        
        # Add tenant field
        custom_fields["_NB_tenant"] = tenant_id
        
        # Flatten the entire event data structure
        flattened_data = flatten_dict(event_data)
        
        # Add all flattened fields with NB_ prefix
        for key, value in flattened_data.items():
            # Skip timestamp and level as they're handled above
            if key not in ["timestamp", "level", "Timestamp"]:
                # Ensure we have a string value for GELF
                if isinstance(value, (dict, list)):
                    value = json.dumps(value)
                elif not isinstance(value, str):
                    value = str(value)
                
                custom_fields[f"_NB_{key}"] = value
        
        # Keep original event data for full_message (for debugging/reference)
        serializable_event_data = {}
        for key, value in event_data.items():
            if isinstance(value, datetime):
                serializable_event_data[key] = value.isoformat()
            elif isinstance(value, (dict, list)):
                serializable_event_data[key] = value
            else:
                serializable_event_data[key] = value
        
        return cls(
            host=host,
            short_message=short_message,
            full_message=json.dumps(serializable_event_data, indent=2),
            timestamp=timestamp,
            level=level,
            custom_fields=custom_fields
        )
